# basic Syntax 1 (1)

## 프로그래밍

### 프로그래밍이란

- **프로그램(program)**: 문제를 해결하기 위한 명령어(지시사항)들의 집합, 컴퓨터에게 내리는 명령어 묶음
- 프로그래밍: 그 명령어 묶음을 만드는 과정
    - 새 연산을 정의하고 조합해 유용한 작업을 수행하는 것

### 프로그래밍 언어

- 컴퓨터에게 작업을 지시하고 문제를 해결하는 도구

---

## python

### ~~python 소개 >~~  python 실행

- python 프로그램 ↔ python 인터프리터 ↔ 운영체제
- Python 인터프리터
    - 사용 방법 1
        - shell이라는 프로그램으로 한 번에 한 명령어씩 입력해서 실행
        - 터미널을 켜고 `python -i`를 입력하면 파이썬 인터프리터 환경이 실행
            
            ```python
            $ python -i
            Python 3.11.9 (tags/v3.11.9:de54cf5, Apr  2 2024, 10:12:12) [MSC v.1938 64 bit (AMD64)] on win32  
            Type "help", "copyright", "credits" or "license" for more information.
            >>> print('hello')
            hello
            >>> 
            ```
            
    - 사용 방법 2
        - 확장자가 `.py` 인 파일에 작성된 python 프로그램을 실행
        - **sample.py** 라는 이름의 python 파일을 만들어 **print( )** 함수를 사용한 예시
            
            ```python
            # sample.py
            print('hello')
            ```
            
        - 이 파일을 Visual Studio Code에서 작성한 뒤, 터미널에서 다음과 같이 입력 후 실행
            
            ```python
            $ python sample.py
            hello
            ```
            
        
        ```python
        SSAFY@DESKTOP-763H707 MINGW64 ~/Desktop/python-master/python-master
        $ cd 01-fundamentals-of-python/
        
        SSAFY@DESKTOP-763H707 MINGW64 ~/Desktop/python-master/python-master/01-fundamentals-of-python
        $ ls
        01-basic.py  02-variable.py
        
        SSAFY@DESKTOP-763H707 MINGW64 ~/Desktop/python-master/python-master/01-fundamentals-of-python
        $ python 01-basic.py
        Hello, World
        
        #run 버튼은 터미널이 덮여지는데 나중에 디버깅할 때 하면 좋음
        ```
        

### 표현식과 값

- **표현식(expression)**: 하나의 ‘값’으로 평가될 수 있는 모든 코드
    - 예시: 3+5  / x > 10 / 5 * 4
- **값(Value)**
    - 표현식이 평가된 경과
    - 더 이상 계산되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각
    - 예시
        - 숫자 값: 103.14
        - 문자열 값: “안녕하세요”
        - 불리언 값: True, False
- **표현식과 값**
    
    표현식→ 3+ 5
    
    값 →  8
    
    <aside>
    ✨
    
    > TIP
    > 
    - 모든 값은 그 자체로 가장 단순한 형태의 표현식이지만, 모든 표현식이 값인 것은 아닙니다.
    - 3+5는 ‘표현식’이지만, 그 자체로 ‘값’은 아니며, 평가를 거쳐야 값 8이 됩니다.
    </aside>
    
    | 개념 | 설명 |
    | --- | --- |
    | 표현식 | 3 + 5같은 값으로 평가될 수 있는 코드 |
    | 평가 | 표현식을 계산하여 값을 만들어 냄 |
    | 값 | 표현식이 평가된 결과 |
    | ⇒  | 표현식을 평가하면 하나의 값이 됨 |

### 변수와 메모리

- **변수(Variable)** : 값을 나중에 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름 “객체를 가리키는 이름”
- **변수 할당(Variable assignment)** : 표현식이 만들어 낸 값에 이름을 붙이는 과정(연결)
- **할당문(Assignment Statement)**
    - “값 36.5을 변수 degrees에 할당했다.”
        - degrees = 36.5
- **변수명 규칙**
    - 영문 알파벳, 언더스코어 _ , 숫자로 수성
    - 숫자로 시작할 수 없음
    - 대소문자를 구분
    - 사람을 위한 인간 친화적인 이름
    - 내부 예약어는 사용할 수 없음
        
        ```python
        False,None,True,__peg_parser__, and, as, assert, async, await,
        break, class, continue, def, del, elif, else, except, finally, for
        fro,. global, if, import, in, is, lambda, nonlocal, not, or, pass
        raise, return, try, while, with, yield
        ```
        
- 변수, 값 그리고 메모리
    - 메모리의 모든 위치에는 그 위치를 고유하게 식별하는 메모리 주소가 존재
    - 컴퓨터가 특정 데이터 값을 정확히 찾아가지 위해 사용하는 기계적인 숫자 주소
    1. **고유한 ID(메모리 주소)**: 제품의 바코드
    2. **타입**: 제품의 종류(예: 정수, 실수, 문자열 등)
    3. **값(Value)**: 제품의 실제 내용물
    - **값 + 타입 + 주소 정보를 묶은 것을 객체(Object)라고 부름**
    - 변수는 특정 객체를 ‘가리키는(refer, point to)’ 이름표
    - 변수는 메모리 주소를 가지지(contain) 않습니다
- 할당문 동작 순서
    - Variable = expression
        1. 오른쪽 표현식 평가
            1. 가장 먼저, 할당 연산자(=)의 오른쪽에 있는 표현식 전체를 계산하여 하나의 결과값(객체)를 만듦
        2. 왼쪽 변수명 확인
            1. 이름이 처음 사용되었다면: 새로운 ‘이름표’ 준비
            2. 이미 존재하는 이름이라면: 기존 ‘이름표’를 그대로 사용
        3. 변수명과 결과값 연결(참조)
            1. 왼쪽의 변수명이 오른쪽에서 만들어진 결과값을 가리키도록 연결
            2. 만약 변수명이 이전에 다른 객체를 가리키고 있었다면, 그 연결은 끊어지고 재할당
- **재할당(reassignment)**
    - 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것
    - 변수는 특정 값을 `기억` 하거나 `가리키는` 이름
    - 재할당은 이 변수가 가리키는 대상을 새로운 값으로 변경하는 행위
        - *재할당이 이루어지면 변수는 이전 값을 완전히 잊고 새로운 값만 기억하게 됨
        
        ```python
        number = 10
        double = 2*number
        print(double) # 20
        
        number = 5
        print(double) #20
        ```
        

## Data Types

### 타입

- **타입 type :** 변수나 값이 가질 수 있는 데이터의 종류를 의미
    - 어떤 종류의 데이터인지, 어떻게 해석되고 처리되어야 하는지를 정의함
    - 값과 값에 적용할 수 있는 2가지 요소로 구분
    - 값이 가질 수 있는 여러 종류를 구분하기 위해 타입이 필요
    - 숫자, 글자, 소수, 어떤 덩어리일 수도 있음
- **Data Types**
    - 값의 종류와 그 값으로 할 수 있는 **‘동작(연산)’을 결정하는 속성**
    - 어떤 데이터가 주어졌을 때 컴퓨터에게 ‘이것은 무엇이고, 이걸로 무엇을 할 수 있는지’를 알려주는 명세서임
- **데이터 타입 분류 5가지**
    - Numeric Types : int(정수), float(실수), complex(복소수)
    - Text Sequence Type : str(문자열)
    - Sequence Type : list, tuple, range
    - Non-Sequence Types : set, dict
    - 기타: Boolean, None, Functions

## Numeric Types

- 숫자형 데이터(Numeric Types)
    - 프로그래밍에서 값을 계산하고, 수량을 세고, 데이터를 분석하는 등 가장 기본이 되는 데이터 타입
    - 크게 2가지 정수형(int), 실수형(float)

### int(정수 자료형)

- 소수점이 없는 숫자를 표현(양수 0, 음수 포함)
    
    ```python
    student_count = 30
    temperature = -5
    balance = 0
    ```
    

### float(실수 자료형)

- 소수점이 있는 더 정밀한 숫자를 표현
    
    ```python
    pi = 3.14
    weight = 65.5
    tax_rate = 0.1
    ```
    
- 지수 표현법
    - 아주 크거나 아주 작은 실수를 간결하게 표현하기 위해 사용하는 방식
    - ‘e’ 또는 ‘E’를 사용
        
        ```python
        # 1,230,000,000 (1.23 * 10^9)
        big_number = 1.23e9
        
        # 0.00314(3.14 * 10^-3)
        small_number = 3.14e-3
        ```
        

### 숫자형의 ‘행동’: 산술 연산

- 숫자형 데이터의 핵심 행동은 `계산`
- 다양한 계산을 위한 산술연산자 제공
    
    
    | 기호 | 설명 | 우선순위 | 연산자 |
    | --- | --- | --- | --- |
    | + | 덧셈 | 높음 | ** |
    | - | 뺄셈 |  | - |
    | * | 곱셈 |  | *, /, //, % |
    | / | 나눗셈 | 낮음 | +, - |
    | // | 몫 나눗셈 |  |  |
    | % | 나머지 |  |  |
    | ** | 거듭제곱 |  |  |
    | - | 음수 부호 |  |  |
    
    ```python
    -2 ** 4 # -16
    (-2)**4 # 16
    ```
    

## Sequence Type

- 여러 개의 값들을 순서대로 나열하여 저장하는 자료형
- 파이썬 대표 시퀀스: str, list, tuple, range
- 인덱스(Index) : 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호
- 공통 특징 5가지
    1. **순서(order)** : 값들이 순서대로 저장(정렬 X)
    2. **인덱싱(Indexing)** : 각 값에 고유번호(인덱스)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
    3. **슬라이싱(Slicing)** : 인덱스 범위를 조정해 전체 데이터 중 원하는 부분만 값을 잘라내서 사용할 수 있음
    4. **길이(Length)** : len( ) 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
    5. **반복(Iteration)** :  반복문을 사용하여 각 값을 하나씩 순서대로 꺼내 사용할 수 있음
    - my_data = “Hello” 라는 문자열 데이터가 있을 때
    
    | 특징 | 사용 예시 | 결과 |
    | --- | --- | --- |
    | 인덱싱 | my_data[1] | ‘e’ |
    | 슬라이싱 | my_data[1:4] | ‘ell’ |
    | 길이 | len(my_data) | 5 |
    | 반복 | for char in my_data: | H, e, l, l, o가 차례로 출력 |

## str(문자열)

- 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형
- 글자들의 시퀀스, 텍스트 데이터를 다루는 법
1. 만들고 표현하는 법
2. 시퀀스로서 활용하는 법
3. ✨불변성✨

### 문자열 만들기

- 작은 따옴표(’)또는 큰 따옴표(”)로 감싸서 표현
- 따옴표 속 따옴표는 서로 다른 종류 사용하기
- 이스케이프 시퀀스(Escape Sequence)
    
    ```python
    # Hello, World!
    print('Hello, World!')
    
    #str
    print(type('Hello, World!'))
    
    # 문자열 안에 '큰따옴표"를 하용하려면 작은 따옴표로 묶는다.
    print('문자열 안에 "큰따옴표"를 사용하려면 작은 따옴표로 묶는다.')
    
    # 따옴표 앞에 \를 붙여 문자로 인식시킴
    print('He\'s a boy.')
    
    # \n 은 줄바꿈(엔터)을 의미
    print('첫째 줄\n둘째 줄')
    
    # 여러 줄 문자열을 작성할 때는 """ 또는 '''를 사용
    multi_line_str = """
    이것은 여러 줄로 이루어진 문자열입니다.
    """
    print(multi_line_str)
    ```
    
    | 예약 문자 | 기능 |
    | --- | --- |
    | \n | 줄 바꿈 |
    | \t | 탭 |
    | \\ | 백슬래시 |
    | \’ | 작은 따옴표 |
    | \” | 큰 따옴표 |

### 문자열에 값 삽입하기: f-string

- 문자열 내에 변수나 표현식의 결과를 손쉽게 삽입하는 강력한 방법
- f-string 사용법
    - 문자열 시작 전 ‘f’ 접두어를 붙이고, 삽입할 부분(표현식)을 중괄호 { } 로 감싸줌
    
    ```python
    name = '홍길동'
    age = 25
    
    greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'
    
    print(greeting)
    # 안녕하세요, 제 이름은 홍길동이고 나이는 25살입니다.
    ```
    
- [ ]  TIL에서는 오늘 배운 내용을 적용한 내용을 적는 것이 중요
- [ ]  소수를 계산할 때는 조심해야 하는구나를 인지

### 시퀀스로서의 문자열

- 문자열은 시퀀스이므로 인덱싱,슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음
    
    
    | 특징 | 사용 예시 | 결과 | 설명 |
    | --- | --- | --- | --- |
    | 인덱싱 | my_data[1] | ‘e’ | 1번 위치의 글자 선택 |
    | 슬라이싱 | my_data[1:4] | ‘ell’ | 1번부터 4번 앞까지 부분 추출 |
    | 길이 | len(my_data) | 5 | 문자열의 전체 길이 |
    | 반복 | for char in my_data: | H, e, l, l, o가 차례로 출력 | 각 문자를 순서대로 처리 |
- 인덱스(index)
    - 시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호
    
    <aside>
    ✨
    
    인덱스는 왜 0부터 시작할까요?
    
    프로그래밍에서 인덱스가 1이 아닌 0부터 시작하는 것은 ‘거리’의 개념
    
    - 인덱스는 시작점으로부터 얼마나 떨어져 있는가를 의미
    - 첫 번째 값은 시작점 바로 그 자체, 떨어진 거리는 0
    - 두 번째 값은 시작점에서 1만큼 떨어져 있음
    
    index 0 
    
    |  | h | e | l | l | o |
    | --- | --- | --- | --- | --- | --- |
    | index | 0 | 1 | 2 | 3 | 4 |
    | index | -5 | -4 | -3 | -2 | -1 |
    </aside>
    
- 슬라이싱(Slicing) : 시퀀스의 일부분을 잘라내어 새로운 시퀀스를 만드는 작업
    - 시작 인덱스와 끝 인덱스를 지정하여 해당 범위의 값을 포함하는 새로운 시퀀스를 생성
    - 대괄호 [ ] 안에  시작 위치, 끝 위치, 간격(step)을 콜론( : )으로 구분하여 지정
    - my_sequence[ start : stop : step ]
        1. start : 슬라이싱을 시작할 인덱스(포함ㅇ)
        2. stop : 슬라이싱을 끝낼 인덱스 (포함x)
        3. step : 몇 개씩 건너뛰며 값을 가져올지에 대한 간격
        
        ```python
        my_str[2:4] #ll
        my_str[:3] #hel
        my_str[3:] #lo
        my_str[::2] # hlo
        my_str[::-1] #olleh
        ```
        

### 문자열의 불변성

- 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형
    
    ```python
    my_str = 'Hello'
    my_str[1] = 'a'
    
    Traceback (most recent call last):
      File "c:\Users\direc\Documents\□ SAFFY\my_str = 'Hello'.py", line 2, in <module>
        my_str[1] = 'a'
        ~~~~~~^^^
    TypeError: 'str' object does not support item assignment
    
    *문자열 객체는 아이템 할당을 지원하지 않습니다."라는 에러가 발생
    ```
    
- 기존 문자열의 일부와 새로운 값을 조합하여 새로운 문자열을 만들어야 함
    
    ```python
    my_str = 'Hello'
    new_str = my_str[0] + 'a' + my_str[2:] # 재할당
    
    print(new_str) #Hallo
    ```
    

## 참고

### 정수형의 진법 표현

```python
# 접두사 제공

# 2진수 10은 10진수로 2입니다. (1 * 2^1 + 0 * 2^0)
print(0b10)

# 8진수 30은 10진수로 24입니다. (3 * 8^1 + 0 * 8^0)
print(0o30)

# 16진수 10은 10진수로 16입니다. (1 * 16^1 + 0 * 16^0)
print(0x10)
```

### 실수의 함정, 부동소수점 오차(Floating-point Rounding Error)

```python
# 부동소수점 에러
result = 0.1 + 0.2
print(result == 0.3)  # False
print(result)  # 0.30000000000000004
```

- 발생 원인
    1. 컴퓨터는 2진법 사용
        1. 컴퓨터는 모든 숫자를 0과 1로 이루어진 2진수로 변환하여 저장
    2. 무한 소수의 발생과 근사값 저장
        1. 우리가 쓰는 10진수 소수 중 일부(예: 0.1)는 2진수로 바꾸면 무한히 반복되는 무한 소수가 됨
        2. 0.1(10진수) → 0.0001100110011. . .(2진수)
        3. 메모리는 유한하기 때문에, 컴퓨터를 이 무한 소수를 어쩔 수 없이 가장 가까운 근사값으로 잘라서 저장함(→ 오차발생, 연산과정에서 문제 ㅇ)
- 해결책: 정확한 계산이 필요할 때
    - decimal 모듈을 사용 : 실수를 2진수로 변환 x, 10진수 자체로 정확하게 연산할 수 있게 해줌

```python

# 해결 전
a = 3.2 - 3.1
b = 1.2 - 1.1

print(a)  # 0.10000000000000009
print(b)  # 0.09999999999999987
print(a == b)  # False
```

```python
# 해결 후
from decimal import Decimal

a = Decimal('3.2') - Decimal('3.1')
b = Decimal('1.2') - Decimal('1.1')

print(a)  # 0.1
print(b)  # 0.1
print(a == b)  # True
```

### 표현식과 문장

- 문장(Statement) : 특정 ‘동작(action)’을 지시하는, 실행 가능한 코드의 최소 단위

<aside>
✨

할당문, 조건문, 반복문.. 여기서 문이 바로 문장(Statement)라는 의미를 가짐

문장은 동작을 ‘기술’하는 것을 넘어, 그 자체로 완결된 하나의 명령이라는 의미 강함

예: 할당문(x = 100), 정의문(def my_function()), 제어문(pass, break,..등)

</aside>

- **표현식 vs 문장이 헷갈린다면?**
    - “이 코드를 실행하면, 그래서 ‘하나의 값’이 남나요?”
    - 표현식 ⇒ 네
        - 어떻게든 계산되거나 평가되어 하나의 값으로 귀결됨(변수에 담을 수 있음)
        - 10 + 20 → 값 30이 남음
        - len(”hello”) → 값 5가 남음
    - 문장 → 아니오
        - 컴퓨터에게 특정 동작을 ‘지시’하고 끝남(값 자체가 남지 않음)
        - **name = “홍길동”** → 값을 변수에 할당하라는 ‘지시’
- 관계도: 문장은 표현식을 ‘재료’로 사용한다
    - 문장 == 요리법
        - 요리의 전체적인 절차와 구조를 나타냄(예: “재료를 섞고 오븐에 구워라.”
    - 표현식 == 재료
        - 요리에 필요한 구체적인 ‘값’(예: 밀가루 500g, 계란 3개)
    - 요리법(문장)에 재료(표현식)가 사용될 수 있고, 때로는 재료(표현식) 하나만으로도 간단한 요리(문장)가 될 수 있다
    - total_price = 5000 + 1500 할당문 예시
    - 5000 + 1500
        - 값 6500을 만들어내는 “표현식”
    - total_price = . . .
        - 표현식이 만든 값을 변수에 할당하라고 지시하는 문장

### Style Guide

- 코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들의 모음
- 파이썬은 PEP 8이 대표적인 스타일 가이드
    - 변수명 : 무엇을 위한 변수인지 직관적인 이름 ㅇ
    - 코드블럭 들여쓰기: 공백 4칸
    - 한 줄의 길이 79자로 제한, 길어질 경우 줄 바꿈
    - 문자와 밑줄(_)을 사용하여 함수, 변수, 속성의 이름을 작성
    - 함수 정의나 클래스 정의 등의 블록 사이에는 빈 줄을 추가\
    - . . . so on..
    - https://peps.python.org/pep-0008/

### 주석(comment)

- 프로그램 코드 내에 작성되는 설명이나 메모
- 주석 예시
    - 주석 처리된 부분은 프로그램 실행에 아무런 영향을 주지 않음(’#’ 기호를 사용)
    - 코드의 복잡한 로직을 설명하거나 특정 부분을 잠시 비활성화할 때 유용하게 사용
    
    ```python
    # 이것은
    age = 10
    """
    여러줄주석
    """
    ```
    

### [python tutor](https://pythontutor.com/)

- 코드 작성 후 ‘render all object on the heap’옵션 선택 → 실행
